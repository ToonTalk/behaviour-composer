; The following are NetLogo library procedures and reporters used by the BehaviourComposer
; New BSD license
; See http://modelling4all.org
; Authored by Ken Kahn; Last updated 2 January 2017 to be compatible with NetLogo 6.0

breed [pens pen]

globals [
 time cycle-finish-time behind-schedule times-scheduled frame-duration delta-t stop-running
 world-geometry mean-x mean-y mean-z plotting-commands histogram-plotting-commands 
 behaviour-procedure-numbers behaviour-names internal-the-other 
 button-command radian need-to-clear-drawing
 observer-commands 
 objects-with-something-to-do
 maximum-plot-generations plot-generation
 prototypes total-time
 update-patch-attributes-needed
 state-restored-after-setup
 temp
]

to start [globals-not-to-be-initialised]
 initialise globals-not-to-be-initialised
 the-model globals-not-to-be-initialised
 finish-setup
 create-pens 1 ; for drawing lines
 ask pens [hide-turtle]
end

to setup
  setup-except []
end

to setup-except [globals-not-to-be-initialised]
 start globals-not-to-be-initialised
 set total-time 0
 if go-until (delta-t - .000001) []  ; ignore result
 ask objects [initialise-previous-state]
end

to initialise [globals-not-to-be-initialised]
 let saved-global-values map runresult globals-not-to-be-initialised
 if-else maximum-plot-generations > 0
    [if-else plot-generation <= maximum-plot-generations
        [let next-plot-generation plot-generation + 1
         ; clear all but plots and output
         clear-patches
         clear-drawing
         clear-turtles
         clear-globals
         set plot-generation next-plot-generation]
        [clear-all
         set plot-generation 0]]
    [clear-all]
 ;; restore the value of any variables in globals-not-to-be-initialised
 let i 0
 while [i < length globals-not-to-be-initialised]
       [let variable item i globals-not-to-be-initialised
        let value item i saved-global-values
        if (not is-number? value and not is-boolean? value and not is-list? value) [set value (word "\"" value "\"")]
        run (word "set " variable " " value)
        set i i + 1]
 reset-timer
 set time -1
 set times-scheduled []
 set behind-schedule 0
 set plotting-commands []
 set histogram-plotting-commands []
 set button-command ""
 set radian 57.29577951308232
 set need-to-clear-drawing false
 set observer-commands []
 set stop-running false
 if delta-t = 0 [set delta-t 1] ; give default value if none given
 if frame-duration = 0 [set frame-duration delta-t]
 if world-geometry = 0 [set world-geometry 1]
 ask-every-patch [ [] -> initialise-patch-attributes ]
 reset-ticks
end

to initialise-object
 set scheduled-behaviours []
 set current-behaviours []
 set behaviour-removals []
 set rules []
 set dead false
 initialise-attributes
end

to finish-setup
 ; faster than ask objects since doesn't shuffle
 set objects-with-something-to-do objects
 let ignore1 objects with [update-attributes]
 ask objects with [rules != []] [run-rules]
 update-all-turtle-states
 set time 0
end

to go
 reset-timer ; reset timer so pause and resume don't have leftover time
 if go-until -1
    [set stop-running false ; so it can be started up again
     stop]
    set total-time total-time + timer
end

to setup-only-if-needed
  if times-scheduled = 0 [setup]
end

to-report go-until [stop-time]
 ; this is run by the 'go' button and runs the scheduled events and updates the turtle states and plots
 setup-only-if-needed
 if observer-commands != []
    [run-observer-commands]
 if-else times-scheduled = []
   ; following uses a hack to avoid the overhead of ask shuffling the agent set
   [set objects-with-something-to-do objects with [rules != []]
    ask objects-with-something-to-do [run-rules] ; nothing scheduled but rules may be triggered by time
    ; rules may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
    ask objects [finish-tick]
    if observer-commands != []
       [run-observer-commands]
    set time time + frame-duration]
   [if-else time <= 0
      [set cycle-finish-time first times-scheduled]
      [set cycle-finish-time cycle-finish-time + frame-duration]
     if stop-time > 0 [set cycle-finish-time stop-time]
     while [times-scheduled != [] and first times-scheduled <= cycle-finish-time]
       [; nothing happening so skip ahead to next event
        set time first times-scheduled
        set times-scheduled but-first times-scheduled
        set objects-with-something-to-do objects with [scheduled-behaviours != [] or rules != []]
        ask objects-with-something-to-do [start-tick]
        ; above may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
        ask objects [finish-tick]
        if observer-commands != []
           [run-observer-commands]
        if need-to-clear-drawing
           [clear-drawing
            set need-to-clear-drawing false]]]
 if observer-commands != []
    [run-observer-commands]
 update-all-turtle-states
 if update-patch-attributes-needed [ask-every-patch [ [] -> update-patch-attributes ]]
 tick-advance time - ticks
 run-plotting-commands
 report not any? objects = 0 or stop-running or (stop-time > 0 and time >= stop-time)
end

to run-observer-commands
  let commands observer-commands
  set observer-commands []
  ; run each command without ANY commands pending
  forEach commands [ [?1] -> run ?1 ]
end

to run-plotting-commands
 forEach plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-plot item 1 ?1 runresult item 2 ?1 runresult item 3 ?1]] ]
 forEach histogram-plotting-commands [ [?1] -> if is-agent? first ?1 [ask first ?1 [update-histogram item 1 ?1 item 2 ?1 item 3 ?1]] ]
end

to add-to-plot [x y]
  ; if using multiple plot generations need to get the pen back to the beginning without drawing a line
  ; assumes the plot starts at zero (or very close to it -- after setup)
  if-else x <= .000001
     [plot-pen-up plotXY x y plot-pen-down]
     [plotXY x y]
end

to update-plot [name-of-plot x y]
 if time >= 0
  [set-current-plot name-of-plot
   plotxy x y]
end

to update-histogram [name-of-plot population-reporter value-reporter]
 if time >= 0
  [set-current-plot name-of-plot
   histogram [runresult value-reporter] of runresult population-reporter]
end

;; behaviours are represented by a list:
;; scheduled-time behaviour-name
;; behaviours are kept in ascending order of the scheduled-time

to remove-behaviour-now [name]
 set scheduled-behaviours remove-behaviour-from-list name scheduled-behaviours
end

to do-every [interval actions]
 ; does it now and schedules the next occurrence interval ticks in the future
 ; schedules first in case action updates the current-behaviour variable
 if-else not is-number? interval or interval <= 0
   [user-message (word "Can only repeat something a positive number of times. Not " interval " " actions)]
   [if-else time < 0
      [insert-behaviour 0 (list (list actions interval))]
      [do-every-internal interval actions]]
end

to do-every-internal [interval actions]
 insert-behaviour time + interval (list (list actions interval))
 run-procedure actions
end

to do-every-dynamic [interval-reporter actions]
 insert-behaviour time + run-result interval-reporter (list (list actions interval-reporter))
 run-procedure actions
end

to do-after [duration actions]
 ; schedules this duration ticks in the future
 if-else is-list? current-behaviour
    ; from the time this event was scheduled to run; not necessarily the current time
    [do-at-time first current-behaviour + duration actions]
    [if-else time > 0
       [do-at-time time + duration actions]
       [do-at-time duration actions]]
end

to do-at-time [scheduled-time actions]
 if-else scheduled-time <= time
   [run actions]
   [insert-behaviour scheduled-time (list actions)]
end

to start-tick
 set behaviours-at-tick-start scheduled-behaviours
 set current-behaviours scheduled-behaviours
 set scheduled-behaviours []
 while [current-behaviours != []]
       [let simulation-time first first current-behaviours
        if-else simulation-time > time
          [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
           set current-behaviours []] ; stop this round
          [set current-behaviour first current-behaviours
           forEach but-first current-behaviour run-procedure
           set current-behaviour 0
           ; procedure may have reset current-behaviours to []
           if current-behaviours != []
              [set current-behaviours but-first current-behaviours]]]
 if rules != [] [run-rules]
 if behaviour-removals != []
    [forEach behaviour-removals
        [ [?1] -> ask first ?1 [remove-behaviour-now item 1 ?1] ]
     set behaviour-removals []]
end

to finish-tick
 ; this should happen after all objects have run start-tick
 let ignore update-attributes
 if dead [die]
end

to-report all-of-kind [kind-name]
 report objects with [kind = kind-name]
end

to when [condition action]
 set rules fput (list condition action false) rules
end

to run-rules
 let current-rules rules
 set rules []
 ; so can remove a rule below while still going down the list
 ;; could add error handling below
 forEach current-rules
    [ [?1] -> if-else runresult first ?1
       [run first but-first ?1
        if item 2 ?1
           ; is a 'whenever' rule so put it back on the list of rules
           [set rules fput ?1 rules]]
       [set rules fput ?1 rules] ]
end

to insert-behaviour [scheduled-time rest-of-behaviour]
 ; inserts in schedule keeping it sorted by scheduled time
 set times-scheduled insert-ordered scheduled-time times-scheduled
 set scheduled-behaviours insert-behaviour-in-list scheduled-time rest-of-behaviour scheduled-behaviours
end

to-report insert-ordered [new-time times]
  if-else member? new-time times
    [report times]
    [report sort fput new-time times]
end

to-report insert-behaviour-in-list [scheduled-time rest-of-behaviour behaviours]
 ; recursive version took 10% longer
 let earlier-behaviours []
 while [behaviours != []]
    [let current-time first first behaviours
      if current-time = scheduled-time
        [let new-behaviour lput first rest-of-behaviour first behaviours
          report sentence earlier-behaviours fput new-behaviour but-first behaviours]
      if current-time > scheduled-time
        [report sentence earlier-behaviours fput fput scheduled-time rest-of-behaviour behaviours]
     set earlier-behaviours lput first behaviours earlier-behaviours
     set behaviours but-first behaviours]
 report sentence earlier-behaviours (list fput scheduled-time rest-of-behaviour)
end

to-report remove-behaviour-from-list [procedure-name behaviours]
 report map [ [?1] -> remove-behaviour-from-behaviours-at-time-t procedure-name ?1 ] behaviours
end

to-report remove-behaviour-from-behaviours-at-time-t [procedure-name behaviours-at-time-t]
 forEach but-first behaviours-at-time-t ; first is the time -- skip that
   [ [?1] -> if equivalent-micro-behaviour? (ifelse-value is-list? ?1 [first ?1] [?1]) procedure-name
      [report remove ?1 behaviours-at-time-t] ]
 report behaviours-at-time-t
end

to-report equivalent-micro-behaviour? [task-1 task-2]
 if (task-1 = task-2) [report true]
 ; different copies of the same micro-behaviour are equivalent for removals
 let serial-number-length 6
 let task-description-1 (word task-1)
 ; need to obtain the procedure name of the task by extracting it from print format
 ; ignore first 30 characters, serial number, and final parenthesis
 if (length task-description-1 - (serial-number-length + 1) <= 30) [report false]
 let name-1 substring task-description-1 30 (length task-description-1 - (serial-number-length + 1))
 let name-2 0
 if-else (is-string? task-2)
   ; older way was to use strings rather than tasks
   [set name-2 substring task-2 0 (length task-2 - serial-number-length)]
   [let task-description-2 (word task-2)
    if (length task-description-2 - (serial-number-length + 1) <= 30) [report false]
    set name-2 substring task-description-2 30 (length task-description-2 - (serial-number-length + 1))]
 report name-1 = name-2
end

to remove-behaviours [behaviours]
 forEach behaviours [ [?1] -> remove-behaviour ?1 ]
end

to remove-behaviour [name]
  set behaviour-removals fput (list self name) behaviour-removals
end

to-report merge-behaviours [behaviours1 behaviours2]
 ; both lists are already sorted
 if behaviours1 = [] [report behaviours2]
 if behaviours2 = [] [report behaviours1]
 if-else first first behaviours1 < first first behaviours2
   [report fput first behaviours1 merge-behaviours but-first behaviours1 behaviours2]
   [report fput first behaviours2 merge-behaviours behaviours1 but-first behaviours2]
end

to ask-every-patch [procedure-name]
 ; a hack but faster since doesn't randomise the patches as ask does
 let ignore patches with [run-false procedure-name]
end

to-report run-false [procedure-name]
 run procedure-name
 report false
end

to-report list-to-agentset [agent-list]
 ; deprecated but kept for backwards compatibility
 report turtle-set agent-list
end

to run-procedure [name]
 if-else is-list? name
    [let target-or-frequency item 1 name
     if-else is-number? target-or-frequency
        [do-every-internal target-or-frequency first name]
        [if-else is-agent? target-or-frequency
            [ask target-or-frequency [run first name]]
            [do-every-dynamic target-or-frequency first name] ]]
    [run name]
end

to-report uninitialised? [x]
 report x = 0 ; uninitialised variables are zero
end

to run-in-observer-context [command]
  set observer-commands fput command observer-commands
end

to-report all-individuals
 report objects with [not hidden?]
end

to-report maximum [n1 n2]
 if-else n1 > n2
   [report n1]
   [report n2]
end

to-report minimum [n1 n2]
 if-else n1 < n2
   [report n1]
   [report n2]
end

to-report second [l]
 report first but-first l
end

to-report third [l]
 report first but-first but-first l
end

to-report fourth [l]
 report first but-first but-first but-first l
end

to-report all-values [variable]
 report [runresult variable] of all-individuals
end

to-report coordinate-between [value min-value max-value modulo]
 ; reports true if value is between min-value and max-value using modulo
 ; assumes that negative values are shifted to between 0 and modulo
 set value value mod modulo
  if-else min-value >= 0
   [if-else max-value < modulo
      [report value >= min-value and value <= max-value]
      [report value >= min-value or value <= (max-value mod modulo)]]
   [if-else max-value < modulo
      [report value <= max-value or value >= (min-value mod modulo)]
      [report true]]
end

to-report canonical-coordinate [value min-value modulo]
 report ((value - min-value) mod modulo) + min-value
end

to set-world-geometry [code]
 set world-geometry code
end

to-report wrapping
 report world-geometry < 4
end

to-report horizontally-wrapping
 report world-geometry < 3
end

to-report vertically-wrapping
 report world-geometry = 1 or world-geometry = 3
end

to-report camera-tracks-centroid
 report world-geometry = 5
end

to-report time-description
 if time < 0 [report " during setup."]
 if time <= .000001 [report " after setup."]
 report (word " after " time " ticks.")
end

to-report corresponding-agentset [agent-list]
 ; deprecated but kept for backwards compatibility 
 report turtle-set agent-list
end

to draw-line [object1 object2 pen-color]
 ask pens [penup
           setxy [xcor] of object1 [ycor] of object1
           set color pen-color
           face object2
           pendown
           jump distance object2]
end

to-report union [list1 list2]
 if empty? list1 [report list2]
 if empty? list2 [report list1]
 if-else random 2 = 0 [ if-else member? first list1 list2 
                           [report union but-first list1 list2]
                           [report fput first list1 union but-first list1 list2]]
                      [ if-else member? first list2 list1 
                           [report union but-first list2 list1]
                           [report fput first list2 union but-first list2 list1]]
end

to-report transform-error-message [error-msg name]
  if-else (member? "WITH" error-msg) and (member? "agentset" error-msg) and (member? "0" error-msg)
         [report (word "A variable in the " name " micro-behaviour has not been initialised. At least one micro-behaviour is missing from the prototype " kind)]
         [report (word error-msg "\nNetLogo error in the micro-behaviour named " name)]
end

to-report transform-patch-error-message [error-msg name]
  report (word error-msg "\nNetLogo error in the micro-behaviour named " name)
end

to-report the-other
  if-else uninitialised? internal-the-other
    [user-message 
      "A micro-behaviour uses 'the-other' and it hasn't been set. It can be set by micro-behaviours with calls to do-for-n, can-pick-one, any, all-who-are, or anyone-who-is."
     report nobody]
    [report internal-the-other]
end

to set-the-other [agent]
 set internal-the-other agent
end

to-report real-time
 ; for backwards compatibility
 report time
end

to-report add-to-list [x the-list]
 if-else is-list? the-list
    [report fput x the-list]
    [report (list x)]
end

to layout-grid [agent-set-or-list lower-left-x lower-left-y width height]
  let agent-list []
  let agent-set nobody
  if-else is-agentset? agent-set-or-list
     [set agent-set agent-set-or-list
      set agent-list [self] of agent-set-or-list]
     [set agent-set list-to-agentset agent-set-or-list
      set agent-list agent-set-or-list]
  let x-min lower-left-x
  let x x-min
  let x-max x + width
  let y-min lower-left-y
  let y y-min
  let y-max y + height
  let maximum-agent-size max [size] of agent-set
  if maximum-agent-size <= 0 [set maximum-agent-size 1]
  while [y < y-max]
    [set x x-min
     while [x < x-max]
       [let agent first agent-list
        ask agent [setxy x y]
        set agent-list but-first agent-list
        if empty? agent-list [stop]
        set x x + maximum-agent-size]
    set y y + maximum-agent-size]
end

to-report add-to-agentset [agent agentset]
  if-else is-agentset? agentset
          [report (turtle-set agent agentset)] 
          [report (turtle-set agent)]
end

to-report other-objects-here
  report objects-here with [self != myself and not hidden?]
end

to-report canonical-heading [h]
 if h > 180 [report h - 360] 
 if h < -180 [report h + 360]
 report h
end



